<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Incision</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; }
    canvas { display: block; }
    #hint {
      position: fixed; bottom: 40px; width: 100%;
      text-align: center; color: rgba(255,255,255,0.2);
      font-family: sans-serif; font-size: 13px; letter-spacing: 0.14em;
      pointer-events: none; transition: opacity 2s ease;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="hint">drag to cut</div>
  <script>
    const canvas = document.getElementById('c');
    const ctx    = canvas.getContext('2d');
    const hint   = document.getElementById('hint');

    // Offscreen canvas: photo with wound areas erased
    const imgCvs = document.createElement('canvas');
    const imgCtx = imgCvs.getContext('2d');

    // Declare all shared variables upfront (no TDZ hazards)
    let W, H;
    let imgScale = 0, imgW, imgH, imgX, imgY;
    let activeCut = null;
    let hintGone  = false;
    let t = 0;

    const KERF  = 30;   // base chainsaw kerf width (px)
    const TEETH = 10;   // jagged edge amplitude per side (px)

    function resize() {
      W = canvas.width  = imgCvs.width  = window.innerWidth;
      H = canvas.height = imgCvs.height = window.innerHeight;
      imgScale = 0;
    }
    resize();
    window.addEventListener('resize', resize);

    // Photo
    const img = new Image();
    img.src = 'source.png';

    // ── Seething background ───────────────────────────────────────────────
    const blobs = [];
    for (let i = 0; i < 9; i++) {
      blobs.push({
        x:     Math.random() * window.innerWidth,
        y:     Math.random() * window.innerHeight,
        vx:    (Math.random() - 0.5) * 0.5,
        vy:    (Math.random() - 0.5) * 0.5,
        r:     0,   // set below after W/H known
        phase: Math.random() * Math.PI * 2,
        freq:  0.015 + Math.random() * 0.02,
      });
    }
    // Set radii now that W/H are known
    blobs.forEach(b => { b.r = (0.12 + Math.random() * 0.22) * Math.min(W, H); });

    function drawSeething() {
      ctx.fillStyle = '#080000';
      ctx.fillRect(0, 0, W, H);
      for (const b of blobs) {
        b.x += b.vx;
        b.y += b.vy;
        b.phase += b.freq;
        if (b.x < -b.r) b.vx =  Math.abs(b.vx);
        if (b.x > W+b.r) b.vx = -Math.abs(b.vx);
        if (b.y < -b.r) b.vy =  Math.abs(b.vy);
        if (b.y > H+b.r) b.vy = -Math.abs(b.vy);
        const p = 0.35 + 0.65 * Math.abs(Math.sin(b.phase));
        const g = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r);
        g.addColorStop(0,    'rgba(' + ((120 + 80*p)|0) + ',0,0,' + (0.65*p).toFixed(2) + ')');
        g.addColorStop(0.4,  'rgba(' + ((50  + 30*p)|0) + ',0,0,' + (0.35*p).toFixed(2) + ')');
        g.addColorStop(1,    'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);
      }
    }

    // ── Image layer with wounds ───────────────────────────────────────────
    function drawImageLayer() {
      if (!img.complete || !img.naturalWidth) return;
      if (!imgScale) {
        imgScale = Math.max(W / img.naturalWidth, H / img.naturalHeight);
        imgW = img.naturalWidth  * imgScale;
        imgH = img.naturalHeight * imgScale;
        imgX = (W - imgW) / 2;
        imgY = (H - imgH) / 2;
      }
      imgCtx.clearRect(0, 0, W, H);
      imgCtx.drawImage(img, imgX, imgY, imgW, imgH);

      // Erase wound areas to reveal seething beneath
      imgCtx.globalCompositeOperation = 'destination-out';
      for (const cut of cuts) eraseWound(cut.points, cut.age / CUT_LIFE);
      if (activeCut)          eraseWound(activeCut.points, 0);
      imgCtx.globalCompositeOperation = 'source-over';

      ctx.drawImage(imgCvs, 0, 0);
    }

    // ── Chainsaw kerf erase (jagged polygon) ──────────────────────────────
    function eraseWound(pts, heal) {
      const n = pts.length;
      if (n < 2) return;
      const scale = 1 - heal;
      if (scale < 0.01) return;

      // Build jagged polygon: forward along left (+normal) side, back along right
      const left = [], right = [];
      for (let i = 0; i < n; i++) {
        const j  = Math.min(i, n - 2);
        const dx = pts[j+1].x - pts[j].x;
        const dy = pts[j+1].y - pts[j].y;
        const L  = Math.sqrt(dx*dx + dy*dy) || 1;
        const nx = -dy / L,  ny = dx / L;
        const taper = Math.min(i / 3, 1, (n - 1 - i) / 3);
        const vib   = (Math.sin(t * 0.52 + i * 2.4) * 3 + Math.sin(t * 0.87 + i * 1.1) * 1.5) * scale;
        const lh = (KERF * 0.5 + (pts[i].nl || 0) * TEETH + vib) * taper;
        const rh = (KERF * 0.5 + (pts[i].nr || 0) * TEETH + vib) * taper;
        left.push({ x: pts[i].x + nx * lh, y: pts[i].y + ny * lh });
        right.push({ x: pts[i].x - nx * rh, y: pts[i].y - ny * rh });
      }

      imgCtx.globalAlpha = scale;
      imgCtx.fillStyle = 'rgba(0,0,0,1)';
      imgCtx.beginPath();
      imgCtx.moveTo(left[0].x, left[0].y);
      for (let i = 1; i < n; i++) imgCtx.lineTo(left[i].x, left[i].y);
      for (let i = n - 1; i >= 0; i--) imgCtx.lineTo(right[i].x, right[i].y);
      imgCtx.closePath();
      imgCtx.fill();
      imgCtx.globalAlpha = 1;
    }

    // ── Wound glow ────────────────────────────────────────────────────────
    function drawGlow(pts, alpha) {
      const n = pts.length;
      if (n < 2) return;
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.lineCap = 'round';
      for (let i = 1; i < n; i++) {
        const taper = Math.min(i / 4, 1, (n - i) / 4);
        const pulse = 0.55 + 0.45 * Math.sin(t * 0.07 + i * 0.6);
        ctx.lineWidth   = 20 + 16 * taper;
        ctx.strokeStyle = 'rgba(180,0,0,' + (0.18 * alpha * pulse).toFixed(3) + ')';
        ctx.shadowBlur  = 28;
        ctx.shadowColor = 'rgba(220,0,0,' + (0.5 * alpha).toFixed(3) + ')';
        ctx.beginPath();
        ctx.moveTo(pts[i-1].x, pts[i-1].y);
        ctx.lineTo(pts[i].x,   pts[i].y);
        ctx.stroke();
      }
      ctx.restore();
    }

    // ── Chainsaw jagged edges + embedded splinters ────────────────────────
    function drawJaggedEdge(pts, alpha) {
      const n = pts.length;
      if (n < 2) return;
      ctx.save();
      ctx.lineCap  = 'butt';
      ctx.lineJoin = 'miter';

      for (const side of [1, -1]) {
        const nk = side === 1 ? 'nl' : 'nr';   // which noise key to use

        // Jagged edge line matching the erased polygon boundary
        ctx.beginPath();
        for (let i = 0; i < n; i++) {
          const j  = Math.min(i, n - 2);
          const dx = pts[j+1].x - pts[j].x;
          const dy = pts[j+1].y - pts[j].y;
          const L  = Math.sqrt(dx*dx + dy*dy) || 1;
          const nx = -dy / L,  ny = dx / L;
          const taper = Math.min(i / 3, 1, (n - 1 - i) / 3);
          const vib   = (Math.sin(t * 0.52 + i * 2.4) * 3.5 + Math.sin(t * 0.87 + i * 1.1) * 1.8) * alpha;
          const half  = (KERF * 0.5 + (pts[i][nk] || 0) * TEETH + vib) * taper;
          const px = pts[i].x + nx * half * side;
          const py = pts[i].y + ny * half * side;
          if (i === 0) ctx.moveTo(px, py);
          else         ctx.lineTo(px, py);
        }
        ctx.lineWidth   = 1.8;
        ctx.strokeStyle = 'rgba(65,4,0,' + (0.92 * alpha).toFixed(3) + ')';
        ctx.shadowBlur  = 5;
        ctx.shadowColor = 'rgba(200,0,0,0.45)';
        ctx.stroke();

        // Embedded splinter spikes radiating outward from the edge
        ctx.lineWidth   = 1.2;
        ctx.shadowBlur  = 2;
        for (let i = 1; i < n - 1; i++) {
          const pt = pts[i];
          if (!pt.sl) continue;
          const j  = Math.min(i, n - 2);
          const dx = pts[j+1].x - pts[j].x;
          const dy = pts[j+1].y - pts[j].y;
          const L  = Math.sqrt(dx*dx + dy*dy) || 1;
          const nx = -dy / L,  ny = dx / L;
          const taper = Math.min(i / 3, 1, (n - 1 - i) / 3);
          const vib   = (Math.sin(t * 0.52 + i * 2.4) * 3.5 + Math.sin(t * 0.87 + i * 1.1) * 1.8) * alpha;
          const half  = (KERF * 0.5 + (pt[nk] || 0) * TEETH + vib) * taper;
          // Base of spike sits on the edge
          const bx = pt.x + nx * half * side;
          const by = pt.y + ny * half * side;
          // Spike extends outward along (normal * side) with angle jitter
          const baseAng = Math.atan2(ny * side, nx * side) + (pt.sa || 0);
          const ex = bx + Math.cos(baseAng) * pt.sl;
          const ey = by + Math.sin(baseAng) * pt.sl;
          ctx.strokeStyle = 'rgba(90,10,0,' + (0.72 * alpha).toFixed(3) + ')';
          ctx.beginPath();
          ctx.moveTo(bx, by);
          ctx.lineTo(ex, ey);
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    // ── Debris particles ──────────────────────────────────────────────────
    const flakes = [];

    function Flake(x, y, nx, ny) {
      const s   = Math.random() < 0.5 ? 1 : -1;
      const sp  = Math.random() * 3 + 0.5;
      // Wide spray angle — chainsaw throws debris broadly
      const ang = Math.atan2(ny, nx) + (Math.random() - 0.5) * Math.PI * 0.75;
      this.x  = x + (Math.random() - 0.5) * 10;
      this.y  = y + (Math.random() - 0.5) * 10;
      this.vx = Math.cos(ang) * s * sp;
      this.vy = Math.sin(ang) * s * sp;
      this.a  = Math.random() * Math.PI;
      this.av = (Math.random() - 0.5) * 0.15;
      // 40%: thin splinter, 60%: irregular chunk
      if (Math.random() < 0.4) {
        this.rx = Math.random() * 14 + 5;
        this.ry = Math.random() * 1.2 + 0.3;
      } else {
        this.rx = Math.random() * 7 + 2;
        this.ry = Math.random() * 5 + 1.5;
      }
      this.life  = 1;
      this.decay = Math.random() * 0.007 + 0.003;
      const r    = (45 + Math.random() * 80) | 0;
      this.fill  = 'rgb(' + r + ',' + ((r * 0.04) | 0) + ',0)';
    }
    Flake.prototype.step = function() {
      this.vy += 0.02; this.vx *= 0.985; this.vy *= 0.985;
      this.x += this.vx; this.y += this.vy;
      this.a  += this.av; this.life -= this.decay;
    };
    Flake.prototype.draw = function() {
      ctx.save();
      ctx.globalAlpha = Math.max(0, this.life) * 0.72;
      ctx.translate(this.x, this.y); ctx.rotate(this.a);
      ctx.fillStyle = this.fill;
      ctx.beginPath();
      ctx.ellipse(0, 0, this.rx, this.ry, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    };

    function spawnFlakes(p0, p1) {
      const dx = p1.x - p0.x, dy = p1.y - p0.y;
      const L  = Math.sqrt(dx*dx + dy*dy);
      if (L < 1) return;
      const nx = -dy/L, ny = dx/L;
      const n  = Math.ceil(L / 6);   // denser than scalpel
      for (let i = 0; i < n; i++) {
        if (Math.random() < 0.65) {
          const r = i / n;
          flakes.push(new Flake(p0.x + dx*r, p0.y + dy*r, nx, ny));
        }
      }
    }

    // ── Chainsaw audio ────────────────────────────────────────────────────
    let audioCtx = null;
    let sawNodes = null;

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } else if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }

    function makeNoiseSrc(ac) {
      const len = ac.sampleRate * 2;
      const buf = ac.createBuffer(1, len, ac.sampleRate);
      const d   = buf.getChannelData(0);
      for (let i = 0; i < len; i++) d[i] = Math.random() * 2 - 1;
      const src = ac.createBufferSource();
      src.buffer = buf;
      src.loop   = true;
      return src;
    }

    function makeDistCurve(amount) {
      const n = 256, c = new Float32Array(n);
      for (let i = 0; i < n; i++) {
        const x = (i * 2) / (n - 1) - 1;
        c[i] = Math.tanh(x * amount);
      }
      return c;
    }

    function startSaw() {
      if (!audioCtx || sawNodes) return;
      const ac  = audioCtx;
      const now = ac.currentTime;

      const master = ac.createGain();
      master.gain.setValueAtTime(0, now);
      master.gain.linearRampToValueAtTime(0.3, now + 0.08);
      master.connect(ac.destination);

      // Engine 1: 65 Hz sawtooth → very heavy clip → lowpass 350 Hz
      const eng1      = ac.createOscillator();
      eng1.type             = 'sawtooth';
      eng1.frequency.value  = 65;
      const eng1Shape = ac.createWaveShaper();
      eng1Shape.curve       = makeDistCurve(12);
      eng1Shape.oversample  = '4x';
      const eng1LP    = ac.createBiquadFilter();
      eng1LP.type           = 'lowpass';
      eng1LP.frequency.value = 350;
      const eng1Gain  = ac.createGain();
      eng1Gain.gain.value   = 0.6;
      eng1.connect(eng1Shape); eng1Shape.connect(eng1LP); eng1LP.connect(eng1Gain); eng1Gain.connect(master);

      // Engine 2: slightly detuned copy for thickness and beating
      const eng2      = ac.createOscillator();
      eng2.type             = 'sawtooth';
      eng2.frequency.value  = 65;
      eng2.detune.value     = 14;
      const eng2Shape = ac.createWaveShaper();
      eng2Shape.curve       = makeDistCurve(12);
      eng2Shape.oversample  = '4x';
      const eng2LP    = ac.createBiquadFilter();
      eng2LP.type           = 'lowpass';
      eng2LP.frequency.value = 350;
      const eng2Gain  = ac.createGain();
      eng2Gain.gain.value   = 0.45;
      eng2.connect(eng2Shape); eng2Shape.connect(eng2LP); eng2LP.connect(eng2Gain); eng2Gain.connect(master);

      // LFO: slow pitch wobble on both engines (2 Hz, ±4 Hz)
      const lfo  = ac.createOscillator();
      lfo.frequency.value  = 2;
      const lfoG = ac.createGain();
      lfoG.gain.value      = 4;
      lfo.connect(lfoG); lfoG.connect(eng1.frequency); lfoG.connect(eng2.frequency);

      // Low rumble noise: white noise → lowpass 280 Hz only
      const noise    = makeNoiseSrc(ac);
      const noiseLP  = ac.createBiquadFilter();
      noiseLP.type          = 'lowpass';
      noiseLP.frequency.value = 280;
      const noiseGain = ac.createGain();
      noiseGain.gain.value  = 0.18;
      noise.connect(noiseLP); noiseLP.connect(noiseGain); noiseGain.connect(master);

      eng1.start(); eng2.start(); lfo.start(); noise.start();
      sawNodes = { master, eng1, eng2, lfo, noise, coughTimer: null };

      // Irregular engine coughs: brief pitch stumble + volume dip
      function scheduleCough() {
        sawNodes.coughTimer = setTimeout(() => {
          if (!sawNodes) return;
          const n = audioCtx.currentTime;
          eng1.frequency.cancelScheduledValues(n);
          eng2.frequency.cancelScheduledValues(n);
          eng1.frequency.setValueAtTime(65, n);
          eng1.frequency.linearRampToValueAtTime(40, n + 0.08);
          eng1.frequency.linearRampToValueAtTime(65, n + 0.30);
          eng2.frequency.setValueAtTime(65, n);
          eng2.frequency.linearRampToValueAtTime(40, n + 0.08);
          eng2.frequency.linearRampToValueAtTime(65, n + 0.30);
          master.gain.cancelScheduledValues(n);
          master.gain.setValueAtTime(0.3, n);
          master.gain.linearRampToValueAtTime(0.08, n + 0.07);
          master.gain.linearRampToValueAtTime(0.3, n + 0.30);
          scheduleCough();
        }, 1800 + Math.random() * 2800);
      }
      scheduleCough();
    }

    function stopSaw() {
      if (!sawNodes) return;
      const { master, eng1, eng2, lfo, noise, coughTimer } = sawNodes;
      clearTimeout(coughTimer);
      const now = audioCtx.currentTime;
      master.gain.setValueAtTime(master.gain.value, now);
      master.gain.linearRampToValueAtTime(0, now + 0.12);
      setTimeout(() => {
        try { eng1.stop(); eng2.stop(); lfo.stop(); noise.stop(); master.disconnect(); } catch(e) {}
      }, 200);
      sawNodes = null;
    }

    // ── Cut management ────────────────────────────────────────────────────
    const cuts    = [];
    const CUT_LIFE = 200;
    const MAX_CUTS = 5;

    // Each point carries stable per-point noise for the jagged edges & splinters
    function makePoint(x, y) {
      return {
        x,  y,
        nl: Math.random() * 2 - 1,                              // left edge noise
        nr: Math.random() * 2 - 1,                              // right edge noise
        sl: Math.random() < 0.28 ? (8 + Math.random() * 14) : 0, // splinter length
        sa: (Math.random() - 0.5) * 0.8,                        // splinter angle jitter
      };
    }

    function getPos(e) {
      const src = e.touches ? e.touches[0] : e;
      return { x: src.clientX, y: src.clientY };
    }

    canvas.addEventListener('mousedown', function(e) {
      initAudio();
      const p = getPos(e);
      activeCut = { points: [makePoint(p.x, p.y)], age: 0 };
      if (!hintGone) { hint.style.opacity = '0'; hintGone = true; }
      startSaw();
    });
    canvas.addEventListener('mousemove', function(e) {
      if (!activeCut) return;
      const p = getPos(e), l = activeCut.points[activeCut.points.length - 1];
      const dx = p.x-l.x, dy = p.y-l.y;
      if (dx*dx + dy*dy > 16) { spawnFlakes(l, p); activeCut.points.push(makePoint(p.x, p.y)); }
    });
    canvas.addEventListener('mouseup', function() {
      if (activeCut && activeCut.points.length > 1) {
        if (cuts.length >= MAX_CUTS) cuts.shift();
        cuts.push(activeCut);
      }
      activeCut = null;
      stopSaw();
    });
    canvas.addEventListener('touchstart', function(e) {
      e.preventDefault();
      initAudio();
      const p = getPos(e);
      activeCut = { points: [makePoint(p.x, p.y)], age: 0 };
      if (!hintGone) { hint.style.opacity = '0'; hintGone = true; }
      startSaw();
    }, { passive: false });
    canvas.addEventListener('touchmove', function(e) {
      e.preventDefault();
      if (!activeCut) return;
      const p = getPos(e), l = activeCut.points[activeCut.points.length - 1];
      const dx = p.x-l.x, dy = p.y-l.y;
      if (dx*dx + dy*dy > 16) { spawnFlakes(l, p); activeCut.points.push(makePoint(p.x, p.y)); }
    }, { passive: false });
    canvas.addEventListener('touchend', function() {
      if (activeCut && activeCut.points.length > 1) {
        if (cuts.length >= MAX_CUTS) cuts.shift();
        cuts.push(activeCut);
      }
      activeCut = null;
      stopSaw();
    });

    // ── Main loop ─────────────────────────────────────────────────────────
    function loop() {
      t++;
      drawSeething();
      drawImageLayer();

      for (let i = cuts.length - 1; i >= 0; i--) {
        const a = Math.max(0, 1 - cuts[i].age / CUT_LIFE);
        drawJaggedEdge(cuts[i].points, a);
        drawGlow(cuts[i].points, a);
        cuts[i].age++;
        if (cuts[i].age >= CUT_LIFE) cuts.splice(i, 1);
      }
      if (activeCut) {
        drawJaggedEdge(activeCut.points, 1);
        drawGlow(activeCut.points, 1);
      }

      for (let i = flakes.length - 1; i >= 0; i--) {
        flakes[i].step();
        flakes[i].draw();
        if (flakes[i].life <= 0) flakes.splice(i, 1);
      }

      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
