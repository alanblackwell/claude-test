<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Incision</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; }
    canvas { display: block; }
    #hint {
      position: fixed; bottom: 36px; width: 100%;
      text-align: center; color: rgba(200,200,200,0.18);
      font-family: sans-serif; font-size: 13px; letter-spacing: 0.14em;
      pointer-events: none; transition: opacity 2s ease;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="hint">drag to cut</div>
  <script>
  (() => {
    const canvas = document.getElementById('c');
    const ctx    = canvas.getContext('2d');
    const hint   = document.getElementById('hint');

    // Offscreen canvas: image with wounds erased
    const imgCvs = document.createElement('canvas');
    const imgCtx = imgCvs.getContext('2d');

    let W, H;
    const resize = () => {
      W = canvas.width = imgCvs.width  = window.innerWidth;
      H = canvas.height = imgCvs.height = window.innerHeight;
      imgScale = 0; // recalculate on next draw
    };
    resize();
    window.addEventListener('resize', resize);

    const img = new Image();
    img.src = 'source.png';
    let imgScale = 0, imgW, imgH, imgX, imgY;

    // ── Seething dark-red background ──────────────────────────────────────
    const blobs = Array.from({ length: 9 }, () => ({
      x:     Math.random(),
      y:     Math.random(),
      vx:    (Math.random() - 0.5) * 0.0007,
      vy:    (Math.random() - 0.5) * 0.0007,
      r:     0.11 + Math.random() * 0.24,
      phase: Math.random() * Math.PI * 2,
      freq:  0.010 + Math.random() * 0.016,
    }));

    function drawSeething() {
      ctx.fillStyle = '#040000';
      ctx.fillRect(0, 0, W, H);
      const dim = Math.min(W, H);
      for (const b of blobs) {
        b.x = ((b.x + b.vx) + 1) % 1;
        b.y = ((b.y + b.vy) + 1) % 1;
        b.phase += b.freq;
        const p  = 0.4 + 0.6 * Math.abs(Math.sin(b.phase));
        const bx = b.x * W, by = b.y * H, br = b.r * dim;
        const g  = ctx.createRadialGradient(bx, by, 0, bx, by, br);
        g.addColorStop(0,    `rgba(${(90 + 90*p)|0},0,0,${0.6*p})`);
        g.addColorStop(0.35, `rgba(${(40 + 30*p)|0},0,0,${0.35*p})`);
        g.addColorStop(0.7,  `rgba(12,0,0,${0.2*p})`);
        g.addColorStop(1,    'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);
      }
    }

    // ── Image layer with wounds cut out ───────────────────────────────────
    function drawImageLayer(t) {
      if (!img.complete || !img.naturalWidth) return;
      if (!imgScale) {
        imgScale = Math.max(W / img.naturalWidth, H / img.naturalHeight);
        imgW = img.naturalWidth  * imgScale;
        imgH = img.naturalHeight * imgScale;
        imgX = (W - imgW) / 2;
        imgY = (H - imgH) / 2;
      }
      imgCtx.clearRect(0, 0, W, H);
      imgCtx.drawImage(img, imgX, imgY, imgW, imgH);

      // Erase wound shapes
      imgCtx.globalCompositeOperation = 'destination-out';
      for (const cut of cuts)
        eraseWound(imgCtx, cut.points, cut.age / CUT_LIFE, t);
      if (activeCut)
        eraseWound(imgCtx, activeCut.points, 0, t);
      imgCtx.globalCompositeOperation = 'source-over';

      ctx.drawImage(imgCvs, 0, 0);
    }

    function eraseWound(c, pts, heal, t) {
      const n = pts.length;
      if (n < 2) return;
      c.lineCap = 'round'; c.lineJoin = 'round';
      for (let i = 1; i < n; i++) {
        const taper  = Math.min(i / 5, 1, (n - i) / 5);
        const wiggle = Math.sin(t * 0.04 + i * 1.3) * 0.7;
        const w = Math.max(0, (3.5 + 3.5 * taper + wiggle) * (1 - heal * 0.9));
        if (w < 0.2) continue;
        c.lineWidth   = w;
        c.strokeStyle = '#000';
        c.beginPath();
        c.moveTo(pts[i-1].x, pts[i-1].y);
        c.lineTo(pts[i].x,   pts[i].y);
        c.stroke();
      }
    }

    // ── Wound glow (dark red light from within) ───────────────────────────
    function drawGlow(pts, alpha, t) {
      const n = pts.length;
      if (n < 2) return;
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.lineCap = 'round';
      for (let i = 1; i < n; i++) {
        const taper = Math.min(i / 5, 1, (n - i) / 5);
        const pulse = 0.6 + 0.4 * Math.sin(t * 0.07 + i * 0.5);
        ctx.lineWidth   = 10 + 7 * taper;
        ctx.strokeStyle = `rgba(150,0,0,${0.10 * alpha * pulse})`;
        ctx.shadowBlur  = 18;
        ctx.shadowColor = `rgba(200,0,0,${0.35 * alpha})`;
        ctx.beginPath();
        ctx.moveTo(pts[i-1].x, pts[i-1].y);
        ctx.lineTo(pts[i].x,   pts[i].y);
        ctx.stroke();
      }
      ctx.restore();
    }

    // ── Peeled edge strips ────────────────────────────────────────────────
    function drawPeel(pts, alpha, t) {
      const n = pts.length;
      if (n < 2) return;
      ctx.save();
      ctx.lineCap = 'round'; ctx.lineJoin = 'round';

      for (const side of [-1, 1]) {
        const path = [];
        for (let i = 0; i < n; i++) {
          const j  = Math.min(i, n - 2);
          const dx = pts[j+1].x - pts[j].x;
          const dy = pts[j+1].y - pts[j].y;
          const L  = Math.hypot(dx, dy) || 1;
          const nx = -dy / L, ny = dx / L;
          const taper   = Math.min(i / 6, 1, (n - 1 - i) / 6);
          const flutter = Math.sin(t * 0.05 + i * 0.85 + side * 1.5) * 2;
          const off = side * (1.5 + 7 * taper + flutter);
          path.push({ x: pts[i].x + nx * off, y: pts[i].y + ny * off });
        }
        ctx.lineWidth   = 2;
        ctx.strokeStyle = `rgba(85,6,0,${0.75 * alpha})`;
        ctx.shadowBlur  = 4;
        ctx.shadowColor = 'rgba(160,0,0,0.3)';
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
        ctx.stroke();
      }
      ctx.restore();
    }

    // ── Flake particles (peeled surface debris) ───────────────────────────
    class Flake {
      constructor(x, y, nx, ny) {
        const s  = Math.random() < 0.5 ? 1 : -1;
        const sp = Math.random() * 1.1 + 0.25;
        this.x  = x;        this.y  = y;
        this.vx = nx*s*sp + (Math.random()-0.5)*0.35;
        this.vy = ny*s*sp + (Math.random()-0.5)*0.35;
        this.a  = Math.atan2(ny, nx);
        this.av = (Math.random()-0.5)*0.06;
        this.rx = Math.random()*9+3;
        this.ry = Math.random()*1.6+0.4;
        this.life  = 1;
        this.decay = Math.random()*0.005+0.003;
        const r = (35 + Math.random()*75)|0;
        this.fill = `rgb(${r},${(r*0.05)|0},0)`;
      }
      step() {
        this.vy += 0.012; this.vx *= 0.987; this.vy *= 0.987;
        this.x += this.vx; this.y += this.vy;
        this.a  += this.av; this.life -= this.decay;
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = Math.max(0, this.life) * 0.6;
        ctx.translate(this.x, this.y); ctx.rotate(this.a);
        ctx.fillStyle = this.fill;
        ctx.beginPath();
        ctx.ellipse(0, 0, this.rx, this.ry, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    const flakes = [];
    function spawnFlakes(p0, p1) {
      const dx = p1.x - p0.x, dy = p1.y - p0.y;
      const L = Math.hypot(dx, dy);
      if (L < 1) return;
      const nx = -dy/L, ny = dx/L;
      const n  = Math.ceil(L / 10);
      for (let i = 0; i < n; i++) {
        if (Math.random() < 0.35) {
          const r = i / n;
          flakes.push(new Flake(p0.x+dx*r, p0.y+dy*r, nx, ny));
        }
      }
    }

    // ── Cut state ─────────────────────────────────────────────────────────
    const cuts    = [];
    let activeCut = null;
    const CUT_LIFE = 200;
    const MAX_CUTS = 5;

    const getPos = e => e.touches
      ? { x: e.touches[0].clientX, y: e.touches[0].clientY }
      : { x: e.clientX,            y: e.clientY };

    let hintGone = false;

    function onStart(e) {
      e.preventDefault();
      activeCut = { points: [getPos(e)], age: 0 };
      if (!hintGone) { hint.style.opacity = '0'; hintGone = true; }
    }
    function onMove(e) {
      e.preventDefault();
      if (!activeCut) return;
      const p = getPos(e), l = activeCut.points[activeCut.points.length - 1];
      if ((p.x-l.x)**2 + (p.y-l.y)**2 > 20) {
        spawnFlakes(l, p);
        activeCut.points.push(p);
      }
    }
    function onEnd() {
      if (activeCut && activeCut.points.length > 1) {
        if (cuts.length >= MAX_CUTS) cuts.shift();
        cuts.push(activeCut);
      }
      activeCut = null;
    }

    canvas.addEventListener('mousedown',  onStart);
    canvas.addEventListener('mousemove',  onMove);
    canvas.addEventListener('mouseup',    onEnd);
    canvas.addEventListener('touchstart', onStart, { passive: false });
    canvas.addEventListener('touchmove',  onMove,  { passive: false });
    canvas.addEventListener('touchend',   onEnd);

    // ── Main loop ─────────────────────────────────────────────────────────
    let t = 0;
    (function loop() {
      t++;

      drawSeething();
      drawImageLayer(t);

      for (const cut of cuts) {
        const a = Math.max(0, 1 - cut.age / CUT_LIFE);
        drawPeel(cut.points, a, t);
        drawGlow(cut.points, a, t);
        cut.age++;
      }
      if (activeCut) {
        drawPeel(activeCut.points, 1, t);
        drawGlow(activeCut.points, 1, t);
      }

      // Remove healed cuts
      for (let i = cuts.length - 1; i >= 0; i--)
        if (cuts[i].age >= CUT_LIFE) cuts.splice(i, 1);

      // Flakes
      for (let i = flakes.length - 1; i >= 0; i--) {
        flakes[i].step();
        flakes[i].draw();
        if (flakes[i].life <= 0) flakes.splice(i, 1);
      }

      requestAnimationFrame(loop);
    })();
  })();
  </script>
</body>
</html>
